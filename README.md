# Integradora II
[![Contribuidores][contribuidores-shield]][contributors-url]

## contenido
<details>
  <summary>Tabla contenidos</summary>
  <ol>
    <li>
      <a href="#acerca-del-proyecto">Acerca del Proyecto</a>
      <ul>
        <li><a href="#descripción">Descripción</a></li>
        <li><a href="#objetivos">Objetivos</a></li>
        <li><a href="#organigrama">Organigrama</a></li>
        <li><a href="#diagrama-gantt">Diagrama Gantt</a></li>
      </ul>
    </li>
    <li>
      <a href="#análisis-de-la-solución">Análisis de la Solución</a>
      <ul>
        <li><a href="#requerimientos">Requerimientos</a></li>
        <li><a href="#diagrama-casos-de-uso">Diagrama de Casos de Uso</a></li>
      </ul>
    </li>
    <li>
      <a href="#diseño-de-la-solución">Diseño de la Solución</a>
      <ul>
        <li><a href="#modelo-relacional">Modelo Relacional</a></li>
        <li><a href="#diagrama-de-clases">Diagrama de Clases</a></li>
        <li><a href="#diagrama-de-componentes">Diagrama de Componentes</a></li>
      </ul>
    </li>    
    <li>
      <a href="#implementación">Implementación</a>
      <ul>
        <li><a href="#estándares-codificación">Estándares Codificación</a></li>
        <li><a href="#arquitectura">Arquitectura</a></li>
        <li><a href="#código-fuente">Código Fuente</a></li>
      </ul>
    </li>      
    <li>
      <a href="#pruebas">Pruebas</a>
      <ul>
        <li><a href="#casos-de-prueba">Casos de prueba</a></li>
        <li><a href="#ejecución">Ejecución</a></li>
      </ul>
    </li>       
    <li><a href="#guias">Guias</a></li>
    <li><a href="#contribucion">Contribución</a></li>
    <li><a href="#licencia">licencia</a></li>
    <li><a href="#contacto">Contacto</a></li>
    <li><a href="#participantes">Participantes</a></li>
  </ol>
</details>

<!-- Acerca del proyecto -->
## Acerca del proyecto
Elaboración de los siguientes módulos:
  *Vista de los clientes que solicitan servicios que se encuetren en el mismo pool de aplicaciones.
  *Vista de los detalles de cada cliente mostrando sus aplicaciones y la ubicacion de su base o bases de datos.
  *Funcionalidad para generar reportes con formato ECXEL aplicando filtros a estos.

<!-- Descripción -->
#### Descripción.
El tiempo de desarrollo del proyecto abarcó un total de 2 meses y una semana.
Costo???
La calidad del entregable final se califica con un 90% del 100 que se esperaba por parte de la empresa.

<!-- Objetivos -->
#### Objetivos.

Optimización de la Interacción con Clientes:

El objetivo principal es mejorar la interacción con los clientes a través de una plataforma 
que permite un acceso rápido y fácil a la información relevante de cada cliente.
Esto se logra mediante una interfaz intuitiva y funciones simplificadas para la inclusión, modificación y eliminación de datos.

Integración de Sistemas Empresariales:

Establecer la funcionalidad para vincular los sistemas de la empresa con los de cada cliente. 
Este objetivo busca lograr una integración perfecta que maximice la eficiencia operativa y la transparencia en las relaciones comerciales.

Eficiencia en la Gestión de Clientes:

Desarrollar una sólida infraestructura de administración de clientes que permita almacenar, 
organizar y gestionar eficientemente la información de cada cliente.
Esto asegura una actualización constante y precisa de los datos, facilitando la toma de decisiones informadas.

Transparencia en la Relación Comercial:

Crear un sistema robusto para definir y administrar contratos y servicios para cada cliente. 
Este objetivo garantiza una transparencia total en las relaciones comerciales, asegurando una 
prestación de servicios alineada con las expectativas del cliente.

Análisis y Optimización de Costos:

Registrar minuciosamente los costos asociados con la gestión y el soporte de sistemas para los clientes.
Este objetivo busca facilitar un análisis detallado de los costos, permitiendo una toma
de decisiones informada y la optimización de recursos.

<!-- Organigrama -->
#### Organigrama.
![image](https://github.com/danonino25/Modulo-Cliente-Servidor/assets/116208398/52ae8221-27b1-480e-a9dc-40924f68bd2c)


<!-- Diagrama Gantt -->
#### Diagrama Gantt.
![image](https://github.com/danonino25/Modulo-Cliente-Servidor/assets/116208398/fe1f687f-36e9-4c5b-907c-699eba13a20e)


<!-- Análisis del proyecto -->
## Análisis de la Solución.
En ésta sección se indicará los artefactos generados en base a la solución.

<!-- Requerimientos -->
#### Requerimientos.
Listado de los requerimientos (código requerimiento, descripción)

<!-- Diagrama de Casos de Uso -->
#### Diagrama Casos de Uso.
Agregar la imagen de los Casos de Uso.



<!-- Diseño del proyecto -->
## Diseño de la Solución.
* Vista Cliente-Servidor.
#
![image](https://github.com/danonino25/Modulo-Cliente-Servidor/assets/116208398/e030ef84-eaec-4c5d-8f39-020ee2002b84)

*Editar URL de acceso.
#
![image](https://github.com/danonino25/Modulo-Cliente-Servidor/assets/116208398/39b9551f-052d-416e-9a5a-8e481d738fd3)

*Editar URL de servidor.
#
![image](https://github.com/danonino25/Modulo-Cliente-Servidor/assets/116208398/0917e30c-75af-4607-92d0-fa80f852071c)


<!-- Modelo Relacional -->
#### Modelo Relacional.
![image](https://github.com/danonino25/Modulo-Cliente-Servidor/assets/116208398/2ef86354-f56e-4cf4-964f-61431ca799cd)

<!-- Diagrama de Clases -->
#### Diagrama de Clases.
Esquema de las clases empleadas (atributos y sus métodos).

<!-- Diagrama de Componentes -->
#### Diagrama de Componentes.
Esquema de los componentes que interactúan (Modelo, Vista, Controlador, Servidor Web, Servidor de base de datos)


<!-- Implementación del proyecto -->
## Implementación.
En ésta sección se describe  los artefactos generados en base a la solución.

<!-- Estándares de Codificación -->
## Estándares de Codificación

### Especificaciones generales

Todo contenido agregado al sistema debe respetar lo siguiente para mantener el orden del código:
- Se trabajará en el idioma predominante en la aplicación de software.
- Todos los nombres de los objetos de base de datos deben tener coherencia con su uso, contenido o funcionalidad.
- No usar caracteres especiales o la letra 'ñ' en el nombramiento de objetos en las bases de datos.

### Bases de Datos

Los objetos de las bases de datos y ellas mismas deben ser nombrados con prefijos que 
representen el tipo de objeto que se está creando. Para nombrar las bases de datos se seguirán las reglas:
- Utilizar sustantivos.
- Usar todo en mayúsculas.
- Hacer uso del prefijo "BD".
- Usar palabras que identifiquen el objetivo de la base de datos.

Ejemplo:

[Prefijo] + [Identificador aplicativo] + [Cliente]*
BDSGCEMPRESA
*Elemento opcional, aplicable mayormente en aplicativos de consultoría.

### Tablas

Las tablas se deben de categorizar en grupos para su fácil identificación y control. El nombre de la tabla se deberá de conformar por un prefijo en minúsculas, mismo que se utilizará dependiendo del tipo de tabla, seguido del nombre de la tabla, para lo cual es necesario considerar que se deben nombrar utilizando sustantivos y estructura camel case, es decir, iniciando con la primera letra de cada palabra en mayúsculas y el resto en minúscula. Además de usar palabras que identifiquen a los datos que se almacenan en las tablas para identificarlas fácilmente.

Es importante destacar que al crear tablas se categorizan en dos grupos principales tablas y catálogos, los catálogos son tablas que se usan como fuente de información y únicamente se requiere obtener información de ellos, estos son de solo lectura. Hacer uso del prefijo “c” para nombrar los catálogos, y “t” para tablas.

Ejemplo:

| Nombre de Tabla                       | Prefijo |
|---------------------------------------|---------|
| Control de Catálogos Estáticos        | ce      |
| Control de Catálogos Parametrizables  | ct      |
| Control de Tablas de Sistema          | ts      |
| Control de Tablas de Log              | tl - tlog |
| Control de Tablas Compuestas          | tr      |
| Control de Históricos                 | th      |

Se debe definir un estándar por proyecto para controlar el agrupamiento de las tablas, estas pueden ser definidas por módulo, por ejemplo:

**SOP**

| Nombre de Tabla                        | Prefijo |
|----------------------------------------|---------|
| Control de Tablas exclusivas para Aéreo       | taer    |
| Control de Tablas exclusivas para Marítimo    | tmar    |
| Control de Tablas exclusivas para Terrestre   | tter    |

Recomendación:

El agrupamiento debería trabajarse a nivel general por módulo de forma que ya sean tabla, vistas, procedimientos almacenados sea fácil identificar visualmente el modulo al que pertenecen.

| Modulo     | Prefijo |
|------------|---------|
| Aéreo      | aer     |
| Marítimo   | mar     |
| Terrestre  | ter     |
| Sistema    | sis     |

### Tipos de Dato SQL

En Transact-SQL existen varios tipos de datos, mismos que han sido clasificados de la siguiente manera para asignarles un prefijo, que será utilizado para nombrar las variables según el tipo de dato bajo el que se declaren.

| Tipo            | Prefijo | Descripción                                     | Tipo de Datos                    |
|-----------------|---------|-------------------------------------------------|----------------------------------|
| NUMÉRICO ENTERO | i       | Tipo de datos utilizados como entero            | Bit, Tinyint, Smallint, Int, BigInt |
| NUMÉRICO DECIMAL| d       | Tipo de datos utilizados con decimales          | Decimal, Float, Real            |
| NUMÉRICO MONETARIO| m     | Tipo de datos utilizados como numéricos monetarios | Money, SmallMoney               |
| FECHA HORA      | dt      | Tipo de datos utilizados para la fecha y hora   | Date, Datetime, SmallDatetime, TimeStamp |
| CADENA          | s       | Tipo de datos utilizados para cadena de caracteres | Char, Varchar, Nchar, Nvarchar |
| BINARIOS        | b       | Tipo de datos utilizados como binarios          | Binary, Varbinary               |

### Atributos – Columnas

El nombre de la columna se conformará con el prefijo del grupo del tipo de dato al que pertenezca en letras minúsculas, seguido del nombre de la columna iniciando con una mayúscula la primera letra de cada palabra que conforme el atributo, es decir, si el nombre de la columna tiene más de una palabra, la siguiente palabra deberá de iniciar también con una mayúscula.

Además es necesario usar palabras que identifiquen los datos que se almacenan dentro del atributo en las tablas para generar su respectivo nombre.

Ejemplo:

“prefijo de tipo de dato” + “nombre de columna”

`sNombreColumna`

### Llaves Primarias (Primary Key)

Nombrar las llaves primarias utilizando el prefijo “pk”, seguido del nombre de la tabla a la que pertenece
la llave y el nombre del atributo al que hace referencia la llave, separados por guion bajo.

Ejemplo:

“Prefijo” + _ + “nombreTabla” + _ + “nombreAtributo”

`Pk_tEmpresa_idEmpresa`

### Llaves Foráneas (Foreign Key)

Nombrar las llaves foráneas utilizando el prefijo ”fk”, seguido del nombre de la tabla a donde viaja la llave, el nombre de la tabla de donde viene la llave y el nombre del atributo al que hace referencia la llave.

Ejemplo:

“Prefijo” +”_”+ “NombreTablaDetino” + _ + “NombreTablaOrigen” + _ + “NombreAtributo”

`Fk_tUsuario_tRol_idRol`

### Declaración de Variables

Cuando se requiera declarar alguna variable en SQL se debe de tomar el mismo criterio que se utiliza para el nombre de columnas de una tabla.

Ejemplo:

“prefijo de tipo de dato” + “Nombre de la variable”

`sNombreVariable`

### Declaración de Constantes

Para la declaración de constantes en SQL se usa el prefijo del tipo de dato en minúsculas y el
nombre que se le quiera dar a la constante en mayúsculas, si la constante tiene más de una palabra debe de separarlo por un guion bajo.

Ejemplo:

“prefijo del tipo de dato” + “NOMBRE_CONSTANTE”

`sNOMBRE_CONSTANTE`

### Procedimientos Almacenados, Funciones, Triggers y Vistas

También se manejarán algunas opciones en SQL los cuales son Funciones, Procedimientos Almacenados, Vistas y Disparadores.
Para cada uno de estos se asignará un prefijo:

| Tipo                   | Prefijo |
|------------------------|---------|
| Disparador – Trigger   | tr      |
| Procedimiento Almacenado - Store Procedure | pa      |
| Vista - View           | vs      |
| Función - Function     | fu      |

Para nombrar estos objetos, es necesario utilizar palabras que hagan referencia al contenido o
funcionalidad de estos, también se debe usar CamelCase y hacer uso del prefijo correspondiente.

Ejemplo: 

“prefijo” + “NombreObjeto”

`vsEmpresa`

Recomendación:

Se recomienda usar el prefijo de módulo como forma para identificar fácilmente o seccionar y clasificar los objetos en la base.

“prefijo” + “PrefijoModulo” + “NombreObjeto”

Ejemplo – prefijo modulo: s – sistema

`vsSisEmpresa` 

**Indicar el módulo al final del nombre a consideración**
 
*Documentar Objetos

Todos los objetos deberán ser documentados utilizando un comentario en la parte superior de
la definición de los objetos con el fin de describir el objetivo de cada uno y poner en contexto al programador sobre su funcionalidad.

Ejemplo:

*El objetivo principal de este [nombre objeto] es el de [breve descripción] 
Seguido por la declaración del objeto.

Comentarios para las palabras reservadas BEGIN/END
Todos los objetos que hagan uso de estas palabras reservadas deberán cumplir con las siguientes características:

El código contenido dentro de ellas debe encontrarse indentado.
La palabra BEGIN debe ser seguida por un comentario con el formato:


-- Inicio de [nombre de la condición que abre]
La palabra END debe ser seguida por un comentario con el formato (Respetando el nombre que se dio en el comentario de la palabra Begin)

-- Fin de [nombre de la condición que cierra]
Ejemplo:


BEGIN -- Inicio de [nombre de la condición que abre]  
  Código  
  Código  
  BEGIN -- Inicio de [nombre de la condición que abre]  
    Código
  END -- Inicio de [nombre de la condición que abre]  
  Código  
END -- Fin de [nombre de la condición que cierra]
Comentarios en el código

Al agregarse comentarios en el código, deberán situarse justo en la línea superior de la instrucción o sentencia, sin líneas en blanco de por medio.

Ejemplo:

--Insersion a la tabla tEmpresa 
Insert into tEmpresa (idEmpresa, nombreEmpresa) values (1, ‘DANA’)
Políticas de uso en sentencias SQL
Al momento de realizar consultas pueden ser estructuradas siguiendo las siguientes recomendaciones de formato:

Renombrar todos los campos según los estándares definidos de columnas, para que al consultarse tengan un nombre asignado, en caso de que la consulta conserve el nombre original este paso puede omitirse.
Uso de diccionario de datos, según el formato definido.
Evitar el uso del comodín (*) en bloques SELECT o INSERT. Siempre hacer referencia a las columnas involucradas. 
Esto evitara los errores, si es que la tabla es modificada agregando columnas.
Agrupar la vista de forma que sea posible visualizarla en pantalla sin necesidad del scroll horizontal, es decir, mantener una longitud coherente para las líneas de código.
No se deberá hacer uso de cursores.
Las columnas usadas en la comparación del bloque JOIN deberán ser indexados.
Evitar el uso de índices duplicados.
Se recomienda el uso de indexado en columnas con alta recurrencia en consultas.
Minimizar el uso de tablas temporales, en su caso optar por el uso de variables de tipo tabla.
Realizar un salto de línea para identificar cada bloque dentro de las sentencias SQL.

Ejemplo:

select tu.sNombreUsuario as sNombreUsuario, 
tc.sCorreo as sCorreoUsuarip
from tUsuario tu
inner join tCorreos tc on tu.idCorreo = tc.idCorreo
left join tEmpresa te on tu.idEmpresa = te.idEmpresa
right join tArea ta on tu.idArea = ta.idArea
full outer join tPuesto tp on tu.idPuesto = tp.idPuesto
where idSolicitud = 1
group by idSolicitud

Recomendaciones adicionales
EL bloque SELECT de una consulta SQL no deberá contener subconsultas.
Estas deben ser trasladadas al bloque FROM.


SELECT (SELECT COUNT (id) FROM tabla) AS fila 
FROM tabla

SELECT t1.columna, t2.columna 
FROM tabla1 t1 
JOIN (SELECT columna, id FROM tabla2) t2 ON t1.id=t2.id
Evitar el uso de condicionales “OR” en los bloques JOIN


SELECT DISTINCT t1.columna 
FROM tabla1 t1 
JOIN tabla2 t2 ON t1.id=t2.id OR t1.uuid=t2.uuid

SELECT t1.columna 
FROM tabla1 t1 JOIN tabla2 t2 ON t1.id=t2.id
UNION
SELECT t1.columna 
FROM tabla1 t1 JOIN tabla2 t2 ON t1.uuid=t2.uuid
No se deberán hacer JOIN a una VISTA.


SELECT t.columna, v.columna 
FROM tabla t 
JOIN vista v ON t.id=v.id

* Realizar JOIN directo con las tablas que forman la vista 
De ser posible, procure el uso del bloque WHERE para devolver solo las filas necesarias y evite el uso de expresiones de
manipulación de datos en este bloque, en su lugar trasládelos al bloque SELECT.


SELECT columna 
FROM tabla 
WHERE CONVERT(DATE,columna) = '2020-01-01'




<!-- Arquitectura MVC y Middleware -->
#### Arquitectura.
Definir los patrones empleados y de seguridad.


<!-- Pruebas proyecto -->
## Pruebas.
En ésta sección se describe  los artefactos generados en base a la solución.

<!-- Casos de prueba -->
#### Casos de prueba.
Indicar los casos de prueba

<!-- Ejecución Casos de prueba -->
#### Ejecución.
Evidencia de Ejecución de Casos de prueba.


## Contacto
Contacto.

## Participantes
* [Juan Diaz Prado]()
* [Miguel Alejandro Espinoza Guzmán]()
* [Emilio Antonio Palacios Arvizu]()
* [Ana María Barrientos Guerrero]()

[contribuidores-shield]: https://img.shields.io/github/contributors/github_username/repo_name.svg?style=for-the-badge
[contributors-url]: https://github.com/github_username/repo_name/graphs/contributors
